" callmekohei's vimrc

if &compatible
  let &compatible = 0
endif

" create autocmd group
augroup MyAutoCmd
  autocmd!
augroup END

" Use English interface.
language message C

" Encoding {{{

  let &encoding      = 'utf-8'
  let &fileencoding  = 'utf-8'
  let &fileencodings = 'ucs-boms,utf-8,euc-jp,cp932'
  let &fileformats   = 'unix,dos,mac'
  if !has('gui_running') && &encoding !=# 'utf-8'
    let &termencoding = 'utf-8'
  endif

  " vimrc's scriptencoding
  scriptencoding utf-8

" }}}

" key mappings {{{

  let g:mapleader      = "\<Space>"
  let g:maplocalleader = "\<Space>"

  " open file by gF, url by gx and Folding line by partEdit
  nnoremap <leader><leader> :call <SID>myOpen()<CR>
  vnoremap <leader><leader> :call <SID>myOpen()<CR>

  " Avoid key mistakes
  nnoremap qqq: <Esc>q:
  nnoremap qqq/ <Esc>q/
  nnoremap q: <Nop>
  nnoremap q/ <Nop>
  nnoremap q? <Nop>

  " Cancel hilight search
  noremap <silent><C-l> :<C-u>nohlsearch<CR><C-l>

  " Search by selected word/sentence ( Practical Vim (ja) : https://pragprog.com/titles/dnvim/source_code )
  xnoremap * :<C-u>call <SID>vSetSearch()<CR>/<C-R>=@/<CR><CR>
  xnoremap # :<C-u>call <SID>vSetSearch()<CR>?<C-R>=@/<CR><CR>
  function! s:vSetSearch()
    let temp = @s
    normal! gv"sy
    let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
    let @s = temp
  endfunction

  " Editor lines
  nnoremap j gj
  nnoremap k gk

  " buffers
  nnoremap <silent> <C-j> :<C-u>bprevious<CR>
  nnoremap <silent> <C-k> :<C-u>bnext<CR>

  " Switch CWD to the directory of the open buffer
  nnoremap <leader>cd :<C-u>cd %:p:h<cr>:<C-u>pwd<cr>

  " yank half
  nnoremap Y y$

  " Toggle window
  " https://qiita.com/grohiro/items/e3dbcc93510bc8c4c812
  nnoremap M :<C-u>call <SID>toggleWindowSize()<CR>
  let s:toggle_window_size = 0
  function! s:toggleWindowSize()
    if s:toggle_window_size ==# 1
      execute "normal \<C-w>="
      let s:toggle_window_size = 0
    else
      :resize
      :vertical resize
      let s:toggle_window_size = 1
    endif
  endfunction

  " vimrc
  nnoremap <leader>v :<C-u>edit $MYVIMRC<CR>

" }}}

" Folding {{{

if has('folding')

  function! s:myFoldText() abort "{{{

    let l:foldchar = matchstr( &fillchars , 'fold:\zs.' )
    let l:foldtext = getline( v:foldstart )

    " Replace unicode spaces to normal space
    " see also: http://www.unicode.org/versions/Unicode11.0.0/ch06.pdf ( page11 Table 6-2.Unicode Space Characters )
    let l:unicodeSpaces = '\v%u180E|%u2028|%u2029|%u00A0|%u2000|%u2001|%u2002|%u2003|%u2004|%u2005|%u2006|%u2007|%u2008|%u2009|%u200A|%u202F|%u205F|%u3000'
    let l:normalSpace = ' '
    let l:foldtext = substitute( l:foldtext,l:unicodeSpaces , l:normalSpace , 'g' )

    " trim head spaces and tail spaces
    let l:headSpaces = '\v^\s+\ze\S'
    let l:tailSpaces = '\v\s+$'
    let l:foldtext = substitute( l:foldtext,l:headSpaces . '|' . l:tailSpaces , '' , 'g' )

    " trim marker
    let l:marker = '{' . '{' . '{'
    let l:spacesBeforeMarker = '\v\s*("|#)?\s*'
    let l:numbersAfterMarker = '\v\s*\d*'
    let l:tmp = l:spacesBeforeMarker . '\m' . l:marker . l:numbersAfterMarker
    let l:foldtext = substitute( l:foldtext, l:tmp , '', 'g' )

    return strpart( '+' . repeat(foldchar, v:foldlevel*2) . ' ' . l:foldtext . ' ' , 0 , ( winwidth(0)*2 )/3 )

  endfunction "}}}

  let &foldmethod = 'marker'
  let &foldtext = get( funcref( 's:myFoldText' ), 'name' ) . '()'

  " Folding ( http://d.hatena.ne.jp/leafcage/20111223/1324705686 )
  noremap <leader>j zj
  noremap <leader>k zk
  noremap <leader>n ]z
  noremap <leader>p [z
  noremap <leader>h zc
  noremap <leader>l zo
  noremap <leader>a za
  noremap <leader>m zM
  noremap <leader>i zMzv
  noremap <leader>r zR
  noremap <leader>f zf

endif

" }}}

" MacVim {{{
  if has('mac')
    " Disable menu.vim for macvim
    " Needs to load before loading plugins
    let did_install_default_menus = 1
    let did_install_syntax_menu   = 1
    let do_no_lazyload_menus      = 1
    let no_buffers_menu           = 1
    let &g:guioptions = 'Mc'
  endif
"}}}

" Plugins {{{

  if ! isdirectory($HOME.'/.vim/pack/pack1')

    syntax on
    filetype plugin indent on

  else

    let &g:packpath = $HOME.'/.vim/pack/pack1,' . &g:packpath

    syntax on
    filetype plugin indent on

    """ plugin setting {{{

    " tomtom/tcomment_vim
    if !exists('g:tcomment_types')
      let g:tcomment_types = {}
    endif
    let g:tcomment_types['']       = '// %s'
    let g:tcomment_types['fsharp'] = '// %s'

    " junegunn/vim-easy-align
    xmap ga <Plug>(EasyAlign)
    nmap ga <Plug>(EasyAlign)

    " nathanaelkane/vim-indent-guides
    map <Nop>(disable-IndentGuidesToggle) <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 1
    let g:indent_guides_start_level = 2
    let g:indent_guides_guide_size  = 1
    let g:indent_guides_auto_colors = 0
    autocmd MyAutoCmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#3A3C43 ctermbg=0
    autocmd MyAutoCmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#3A3C43 ctermbg=0

    " thinca/vim-quickrun
    let g:quickrun_no_default_key_mappings = 1
    let g:quickrun_config   = {}
    let g:quickrun_config._ = {
    \  'hook/time/enable'                : 1
    \ ,'hook/time/format'                : "\n*** time : %g s ***"
    \ ,'hook/time/dest'                  : ''
    \ ,"outputter/buffer/split"          : 'vertical'
    \ ,'outputter/buffer/close_on_empty' : 1
    \}

    " romainl/Apprentice ( ColorScheme )
    " re-difine highlight group
    function! s:myHighlights() abort
      highlight Comment        ctermfg=245  guifg=#8a8a8a
      highlight FoldColumn     ctermfg=245  guifg=#8a8a8a
      highlight Folded         ctermfg=245  guifg=#8a8a8a
      highlight UnicodeSpaces  ctermbg=131  guibg=#af5f5f
      highlight OptionKeyword  ctermfg=103  guifg=#8787af
    endfunction
    autocmd MyAutoCmd ColorScheme * call s:myHighlights()

    if has('mac')

      " set color scheme
      let &g:background = 'dark'
      colorscheme Apprentice

      " unicodeSpaces color
      call matchadd(
      \     'UnicodeSpaces'
      \   , '\v%u180E|%u2028|%u2029|%u00A0|%u2000|%u2001|%u2002|%u2003|%u2004|%u2005|%u2006|%u2007|%u2008|%u2009|%u200A|%u202F|%u205F|%u3000'
      \ )

    elseif has('win32unix')

      set background=light
      colorscheme lucius
      LuciusLightHighContrast

      " vimdiffの色設定
      highlight DiffAdd    cterm=bold ctermfg=10 ctermbg=22
      highlight DiffDelete cterm=bold ctermfg=10 ctermbg=52
      highlight DiffChange cterm=bold ctermfg=10 ctermbg=17
      highlight DiffText   cterm=bold ctermfg=10 ctermbg=21

    endif

    " MemoList
    nnoremap <leader>, :<C-u>MemoNew<CR>
    nnoremap <leader>. :<C-u>MemoList<CR>
    nnoremap <leader>/ :<C-u>MemoGrep<CR>

    """ }}}

  endif

  " enable ':Man' command
  runtime ftplugin/man.vim
  let g:ft_man_folding_enable = 1

" }}}

" options {{{

  " Search
  let &ignorecase = 1
  let &smartcase  = 1
  let &incsearch  = 1
  let &hlsearch   = 1
  let &wrapscan   = 1

  " Edit
  let &tabstop         = 4
  let &softtabstop     = 4
  let &shiftwidth      = 4
  let &expandtab       = 1
  let &smarttab        = 1
  let &autoindent      = 1
  let &smartindent     = 0
  let &backspace       = 'indent,eol,start'
  let &showmatch       = 0
  let &wildmenu        = 1
  let &formatoptions   = 'mM'
  let &virtualedit     = 'block'

  " View
  let &number     = 1
  let &ruler      = 0
  let &list       = 1
  let &listchars  = 'tab:> ,trail:-,nbsp:+,extends:»,precedes:«,'
  let &wrap       = 0
  let &laststatus = 2
  let &cmdheight  = 2
  let &showcmd    = 0
  let &title      = 1

  " mouse
  let &mouse      = 'a'
  let &mousefocus = 0
  let &mousehide  = 0
  if has('win32unix')
    set ttymouse=xterm2
  endif

  " clipboard
  if (!has('nvim') || $DISPLAY !=# '') && has('clipboard')
    if has('unnamedplus')
      let &clipboard = 'unnamedplus'
    else
      let &clipboard = 'unnamed'
    endif
  endif

  " others
  let &lazyredraw = 1
  let &hidden     = 1
  let &splitright = 1
  let &ttyfast    = 1

  " Disable bell.
  let &t_vb       = ''
  let &visualbell = 0
  let &belloff    = 'all'

  " Don't create backup.
  let &writebackup = 0
  let &backup      = 0
  let &swapfile    = 0
  set backupdir-=.

" }}}

" filetypes {{{

" vb {{{

  autocmd MyAutoCmd BufRead,BufNewFile *.cls
  \ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6).getline(7).getline(8).getline(9).getline(10) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)' |
  \   set filetype=vb |
  \ elseif getline(1) =~ '^%' |
  \   set filetype=tex |
  \ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
  \   set filetype=rexx |
  \ else |
  \   set filetype=st |
  \ endif

  function! s:vimrc_vb() abort
    let &l:foldmethod  = 'marker'
    let &l:tabstop     = 4
    let &l:softtabstop = 4
    let &l:shiftwidth  = 4
    let &l:ambiwidth   = 'double'
    " encoding
    let &fileencoding  = 'cp932'
    let &fileformat   = 'dos'
  endfunction
  autocmd MyAutoCmd BufRead,BufNewFile *{.bas,.cls} call s:vimrc_vb()

" }}}

" shell {{{

function! s:vimrc_bash() abort

  let g:is_bash      = 1
  let g:sh_no_error  = 1

  let &l:tabstop     = 2
  let &l:softtabstop = 2
  let &l:shiftwidth  = 2
  let &l:foldmethod  = 'marker'
  let &l:errorformat = '%f:\ line\ %l:\ %m'

  " quickrun settings
  " let g:quickrun_config.sh        = {}
  " let g:quickrun_config.bashCheck = {}
  " let g:quickrun_config.sh        = { 'command': 'bash' }
  " let g:quickrun_config.bashCheck = {
  "   \  'exec'                            : [ '%c -n %s:p:r.bash' ]
  "   \ ,'command'                         : 'bash'
  "   \ ,'hook/time/enable'                : 0
  "   \ ,"outputter/buffer/close_on_empty" : 1
  "   \ ,"outputter"                       : 'quickfix'
  "   \ ,'outputter/buffer/split'          : ':set splitblow',
  " \}

endfunction
call s:vimrc_bash()

"}}}

" vim {{{

  if line('$') > 1000
    syntax sync minlines=200
  endif

  function! s:vimrc_vim() abort
    let g:vim_indent_cont = 2
    let &l:tabstop        = 2
    let &l:softtabstop    = 2
    let &l:shiftwidth     = 2
    let &l:foldmethod     = 'marker'
  endfunction
  call s:vimrc_vim()

  " let-option color
  call matchadd( 'OptionKeyword', '\s&\zs\w*\ze$' )
  call matchadd( 'OptionKeyword', '\s&\zs\w*\ze\s')
  call matchadd( 'OptionKeyword', '\s&\(g:\|l:\)\zs\w*\ze\s')

" }}}

  " Trim tail spaces ( exception: markdown, text )
  autocmd MyAutoCmd BufWritePre * if index(['markdown'], &ft) == -1 | :call s:trimEnd() | endif

  " set filetype
  autocmd MyAutoCmd BufNewFile,BufRead inputrc,bash_profile setlocal filetype=sh


" }}}

" Vim Cursor like neovim {{{

  " cursor like neovim ( :h terminal-option )
  if has('vim_starting')
    if ! has('nvim')
      if ! has ('gui_running')
        let &t_SI .= "\e[6 q" " start insert mode
        let &t_EI .= "\e[2 q" " end insert mode
        let &t_SR .= "\e[4 q"
        " not work <localleader> if turn on timeoutlen
        " let &timeoutlen = 100
      endif
    endif
  endif

" }}}

" macvim {{{

  if has('gui_running')

    " font
    let s:fontName = 'Droid Sans Mono for Powerline Nerd Font Complete'
    let s:fontSize = 'h14'
    let &g:guifont   = s:fontName . ':' . s:fontSize
    let &g:linespace = 3

    " window size
    let &g:columns   = 80 " width
    let &g:lines     = 30 " hight
    let &g:cmdheight = 2

    " Don't flick cursor.
    setglobal guicursor&
    setglobal guicursor+=a:blinkon0

    " key mappings
    noremap  ; :
    noremap  : ;
    lnoremap ; :
    lnoremap : ;
    tnoremap ; :
    tnoremap : ;

  endif

" }}}

" neovim {{{

  if has('nvim')

    let g:python_host_prog  = '/usr/local/bin/python2'
    let g:python3_host_prog = '/usr/local/bin/python3'

    if exists('&inccommand')
      let &g:inccommand = 'nosplit'
    endif

  endif

" }}}

" mac/osx {{{

  if has('mac')

    " Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
    " https://github.com/koron/vim-kaoriya/blob/master/kaoriya/vim/vimrc#L221
    let &iskeyword = '@,48-57,_,128-167,224-235'

  endif

" }}}

" util {{{

  " https://qiita.com/sgur/items/9e243f13caa4ff294fa8
  command! -nargs=+ -complete=command Capture QuickRun -type vim -src <q-args>

  command! SelfFileDelete call delete(expand('%',1))

  inoreabbrev <expr> ---- repeat('-', 60 - col('.'))

  function s:myOpenImpl(...) abort "{{{

    let l:s = expand('<cfile>')

    if l:s ==# ''
      return
    endif

    if stridx(l:s,'http') >= 0
      :normal gx
      return
    endif

    let l:fp = split(expand(l:s),':')[0]

    if filereadable(l:fp)
      :normal gF
      return
    endif

    return 9999

  endfunction "}}}
  function! s:myOpen() range "{{{

    if call('foldclosed',[line('.')]) !=# -1

      normal!v
      normal!:
      normal!`<
      let l:fstline = line(".")
      normal!`>
      let l:lstline = line(".")

      execute l:fstline .',' . l:lstline . 'Partedit'

    else

      let l:selectedMultiLines = a:lastline - a:firstline

      if l:selectedMultiLines > 0
        execute a:firstline .',' . a:lastline . 'Partedit'
      else

        let l:s = expand('<cfile>')

        if l:s ==# ''
          execute a:firstline .',' . a:lastline . 'Partedit'
          return
        endif

        if call( 's:myOpenImpl', [] ) == 9999
          execute a:firstline .',' . a:lastline . 'Partedit'
        endif

      endif

    endif

  endfunction "}}}
  function! s:trimEnd() abort "{{{

    :normal! ma

    let l:range = '%'

    " Replace unicode spaces to normal space
    let l:unicodeSpaces  = '\%u00A0\|\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000'
    :execute l:range 'substitute' '/' . l:unicodeSpaces . '/ /ge'

    " trim tail spaces
    let tailSpaces = '\s+$'
    :execute l:range 'substitute' '/\v' . l:tailSpaces . '//ge'

    :normal! `a

  endfunction "}}}
  " do center selected strings {{{

  command! -range Center2 call s:center2(<line1>,<line2>)
  function! s:center2(fst,lst) abort
    let l:maxcol = max(map(getline(a:fst,a:lst),'strlen(v:val)'))
    execute (a:fst) "," (a:lst) "center" l:maxcol
  endfunction

  "}}}
  " cleare selected empty lines {{{

  command! -range ClearEmptyLines call s:clearEmptyLines(<line1>,<line2>)
  function! s:clearEmptyLines(fst,lst) abort
    execute (a:fst) "," (a:lst) 'vglobal/\S/d'
  endfunction

  "}}}
  command! -range Space2from4 call s:space2from4() "{{{
  function! s:space2from4() abort
    let &l:tabstop     = 4
    let &l:softtabstop = 4
    let &l:expandtab   = 0
    retab!
    let &l:tabstop     = 2
    let &l:softtabstop = 2
    let &l:expandtab   = 1
    retab
  endfunction "}}}
  command! -range Space4from2 call s:space4from2() "{{{
  function! s:space4from2() abort
    let &l:tabstop     = 2
    let &l:softtabstop = 2
    let &l:expandtab   = 0
    retab!
    let &l:tabstop     = 4
    let &l:softtabstop = 4
    let &l:expandtab   = 1
    retab
  endfunction "}}}


  " count words {{{

  command! -range Count call s:count(<line1>,<line2>)
  function! s:count(fst,lst) abort
    execute (a:fst) "," (a:lst) 's/&/&/g'
  endfunction

  "}}}

" }}}

" __END__  "{{{

  " must be written at the last. see :help 'secure'
  let &g:secure = 1

  " vim: expandtab softtabstop=2 shiftwidth=2
  " vim: foldmethod=marker
  " vim: foldcolumn=5

" }}}
