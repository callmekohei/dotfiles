" callmekohei's vimrc

" option flag
let s:ON  = 1 | :lockvar s:ON
let s:OFF = 0 | :lockvar s:OFF

" prepare {{{1

  if &compatible
    let &compatible = s:OFF
  endif

  " Make the vim option the same as the neovim option {{{2
  if !has('nvim')

    " :h nvim-defaults

    let &autoindent     = s:ON
    let &autoread       = s:ON
    let &backspace      = 'indent,eol,start'
    let &backupdir      = '.' . ',' . expand('~/.local/share/nvim/backup',1)
    let &belloff        = 'all'
    let &complete       = '.,w,b,u,t'
    let &cscopeverbose  = s:ON
    let &directory      = expand('~/.local/share/nvim/swap//',1)
    let &display        = 'lastline,msgsep'
    let &encoding       = 'utf-8'
    let &fillchars      = "vert:│,fold:·"
    let &fsync          = s:OFF
    let &formatoptions  = 'jcroql'
    let &history        = 10000
    let &hlsearch       = s:ON
    let &incsearch      = s:ON
    let &langnoremap    = s:ON
    let &langremap      = s:OFF
    let &laststatus     = 2
    let &listchars      = 'tab:> ,trail:-,nbsp:+'
    let &nrformats      = 'bin,hex'
    let &ruler          = s:ON
    let &sessionoptions = 'blank,buffers,curdir,folds,help,tabpages,winsize'
    let &showcmd        = s:ON
    let &sidescroll     = s:ON
    let &smarttab       = s:ON
    let &tabpagemax     = 50
    let &tags           = './tags,tags'
    let &ttyfast        = s:ON
    let &undodir        = expand('~/.local/share/nvim/undo',1)
    let &viminfo        = "!,'100,<50,s10,h"
    let &wildmenu       = s:ON

  endif
  " }}}2

  " encoding
  let &encoding      = 'utf-8'
  let &fileencoding  = 'utf-8'
  let &fileencodings = 'ucs-boms,utf-8,euc-jp,cp932'
  let &fileformats   = 'unix,dos,mac'
  if !has('gui_running') && &encoding !=# 'utf-8'
    let &termencoding = 'utf-8'
  endif

  " vimrc's scriptencoding
  scriptencoding utf-8

  " create autocmd group
  augroup callmekohei-vimrc
    autocmd!
  augroup END

  " Use English interface.
  language message C

  " Disable menu.vim
  let did_install_default_menus = 1
  let did_install_syntax_menu   = 1
  let do_no_lazyload_menus      = 1
  let no_buffers_menu           = 1
  let &g:guioptions = 'Mc'

" }}}1 -------------------------------------------------
" plugins {{{1

  function! s:dein_load_plugins(nvim_home) abort "{{{2

    call dein#load_toml( a:nvim_home . '/deinlazy.toml', {'lazy': 1} )

    if !has('nvim')
      call dein#add('roxma/nvim-yarp')
      call dein#add('roxma/vim-hug-neovim-rpc')
      call dein#add('callmekohei/tigaDebugger')
    endif

    call dein#add(expand('$HOME/tmp/vim-partedit',1))

    call dein#add('Shougo/dein.vim')
    call dein#add('Shougo/vimproc.vim',{'build':'make'})
    call dein#add('glidenote/memolist.vim')
    call dein#add('junegunn/fzf.vim',{'build':'./install --all','hook_add':'source ~/dotfiles/vim/plugins/fzf.rc.vim'})
    call dein#add('junegunn/vim-easy-align')
    call dein#add('kana/vim-textobj-user')
    call dein#add('mattn/sonictemplate-vim')
    call dein#add('nathanaelkane/vim-indent-guides')
    call dein#add('romainl/Apprentice')
    call dein#add('thinca/vim-quickrun',{'depends':'Shougo/vimproc.vim'})
    call dein#add('thinca/vim-ref')
    call dein#add('tomtom/tcomment_vim')
    call dein#add('vim-jp/vimdoc-ja')

  endfunction "}}}2
  function! s:dein_easy_settings() abort "{{{2

    let l:config_home = empty($XDG_CONFIG_HOME) ? expand('~/.config',1) : $XDG_CONFIG_HOME
    let l:cache_home  = empty($XDG_CACHE_HOME)  ? expand('~/.cache',1)  : $XDG_CACHE_HOME
    let l:nvim_home   = l:config_home . '/nvim'
    let l:dein_home   = l:cache_home  . '/dein'
    let l:dein_dir    = l:dein_home   . '/repos/github.com/Shougo/dein.vim'

    if !isdirectory(l:dein_dir )
      call system('git clone --depth 1 https://github.com/Shougo/dein.vim ' . shellescape(l:dein_dir ))
    endif

    let &g:runtimepath = l:dein_dir  . "," . &g:runtimepath

    if dein#load_state(l:dein_home)
      call dein#begin(l:dein_home)
      call s:dein_load_plugins(l:nvim_home)
      call dein#end()
      call dein#save_state()
    endif

    if has('vim_starting') && dein#check_install()
      call dein#install()
    endif

  endfunction "}}}2
  function! s:plugins_settings() abort "{{{

  " tomtom/tcomment_vim {{{

    if !exists('g:tcomment_types')
      let g:tcomment_types = {}
    endif

    let g:tcomment_types['']          = '// %s'
    let g:tcomment_types['fsharp']    = '// %s'
    let g:tcomment_types['mql4']      = '// %s'
    let g:tcomment_types['text']      = '// %s'
    let g:tcomment_types['text.memo'] = '// %s'

  " }}}
  " junegunn/vim-easy-align {{{

    xmap ga <Plug>(EasyAlign)
    nmap ga <Plug>(EasyAlign)

  " }}}
  " thinca/vim-ref {{{

    " TODO:urlをよみこめない
    let g:ref_man_cmd            = 'man'
    let g:ref_pydoc_cmd          = 'python3 -m pydoc'
    let g:ref_source_webdict_cmd = 'w3m -dump %s'
    let g:ref_use_vimproc        = v:true

    "webdictサイトの設定
    let g:ref_source_webdict_sites = {
    \     'fsharp': { 'url'   : 'https://github.com/MicrosoftDocs/visualfsharpdocs/tree/live/docs/conceptual/%s'}
    \   , 'alk' : { 'url' : 'http://eow.alc.co.jp/%s/UTF-8/' }
    \ }

    " 出力に対するフィルタ
    function! g:ref_source_webdict_sites.fsharp.filter(output)
      let l:lst  = split(a:output, "\n")
      call filter(l:lst,{idx, val -> val =~ '.md'} )
      return join(l:lst,"\n")
    endfunction

  " }}}
  " thinca/vim-quickrun {{{

    let g:quickrun_no_default_key_mappings = 1
    let g:quickrun_config   = {}
    let g:quickrun_config._ = {
    \  'runner'                          : 'vimproc'
    \ ,'runner/vimproc/updatetime'       : 60
    \ ,'hook/time/enable'                : 1
    \ ,'hook/time/format'                : "\n*** time : %g s ***"
    \ ,'hook/time/dest'                  : ''
    \ ,"outputter/buffer/split"          : 'vertical'
    \ ,'outputter/buffer/close_on_empty' : 1
    \}

  " }}}
  " thinca/vim-partedit {{{

    let g:partedit#opener   = 'vsplit'
    let g:partedit#filetype = 'vim'

  " }}}
  " glidenote/memolist.vim {{{

    let g:memolist_path = expand("$HOME/Dropbox/memo",1)
    let g:memolist_memo_suffix = "memo"
    let g:memolist_template_dir_path = g:memolist_path
    let g:memolist_ex_cmd = 'Files'
    autocmd callmekohei-vimrc VimEnter * command! -nargs=* MemoGrep
      \ call fzf#vim#ag( <q-args> , fzf#vim#with_preview( {'dir':g:memolist_path}, 'right:50%' ) )

  " }}}
  " nathanaelkane/vim-indent-guides {{{

    map <Nop>(disable-IndentGuidesToggle) <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 1
    let g:indent_guides_start_level = 2
    let g:indent_guides_guide_size  = 1
    let g:indent_guides_auto_colors = 0
    autocmd callmekohei-vimrc VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#3A3C43 ctermbg=0
    autocmd callmekohei-vimrc VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#3A3C43 ctermbg=0

  " }}}
  " kana/textobj {{{

    call textobj#user#plugin('yyy', {} )
    call textobj#user#plugin('yyy', {
    \ 'bbb': {
    \   'pattern': ["^hook.* = '''","^'''"],
    \   'select-a': 'aP',
    \   'select-i': 'iP',
    \   },
    \ })

  " }}}

  endfunction "}}}

  autocmd callmekohei-vimrc CursorHold *.toml syntax sync minlines=300
  call s:dein_easy_settings()
  call s:plugins_settings()

  " turn plugins on
  syntax on
  filetype plugin indent on

" }}}1 plugins   ---------------------------------------
" colorscheme {{{1

  function! s:myHighlights() abort
    highlight Comment       ctermfg=245   guifg=#8a8a8a
    highlight FoldColumn    ctermfg=245   guifg=#8a8a8a
    highlight Folded        ctermfg=245   guifg=#8a8a8a
    highlight OptionKeyword ctermfg=103   guifg=#8787af
    highlight UnicodeSpaces ctermbg=131   guibg=#af5f5f
  endfunction
  autocmd callmekohei-vimrc ColorScheme * call s:myHighlights()

  let &g:background = 'dark'
  colorscheme Apprentice

" }}}1 -------------------------------------------------
" options {{{1

  " Search
  let &ignorecase = s:ON
  let &smartcase  = s:ON
  let &incsearch  = s:ON
  let &hlsearch   = s:ON
  let &wrapscan   = s:ON

  " Edit
  let &tabstop         = 4
  let &softtabstop     = 4
  let &shiftwidth      = 4
  let &expandtab       = s:ON
  let &smarttab        = s:ON
  let &autoindent      = s:ON
  let &smartindent     = s:OFF
  let &backspace       = 'indent,eol,start'
  let &showmatch       = s:OFF
  let &wildmenu        = s:ON
  let &formatoptions   = 'mM'
  let &virtualedit     = 'block'

  " View
  let &number     = s:ON
  let &ruler      = s:OFF
  let &list       = s:ON
  let &listchars  = 'tab:> ,trail:-,nbsp:+,extends:»,precedes:«,'
  let &wrap       = s:OFF
  let &laststatus = 2
  let &cmdheight  = 2
  let &showcmd    = s:OFF
  let &title      = s:ON

  " mouse
  let &mouse      = 'a'
  let &mousefocus = s:OFF
  let &mousehide  = s:OFF

  " clipboard
  if (!has('nvim') || $DISPLAY !=# '') && has('clipboard')
    if has('unnamedplus')
      let &clipboard = 'unnamedplus'
    else
      let &clipboard = 'unnamed'
    endif
  endif

  " others
  let &lazyredraw = s:ON
  let &hidden     = s:ON
  let &splitright = s:ON
  let &ttyfast    = s:ON

  " Disable bell.
  let &t_vb       = ''
  let &visualbell = s:OFF
  let &belloff    = 'all'

  " Don't create backup.
  let &writebackup = s:OFF
  let &backup      = s:OFF
  let &swapfile    = s:OFF
  set backupdir-=.

" }}}1 -------------------------------------------------
" key mappings {{{1

  let g:mapleader      = "\<Space>"
  let g:maplocalleader = "\<Space>"

  " open file with line number
  nnoremap gf gF
  vnoremap gf gF

  " open url with web browser
  nmap <leader><leader> gx

  " Avoid key mistakes
  nnoremap qqq: <Esc>q:
  nnoremap qqq/ <Esc>q/
  nnoremap q: <Nop>
  nnoremap q/ <Nop>
  nnoremap q? <Nop>

  " Folding ( http://d.hatena.ne.jp/leafcage/20111223/1324705686 )
  noremap <leader>j zj
  noremap <leader>k zk
  noremap <leader>n ]z
  noremap <leader>p [z
  noremap <leader>h zc
  noremap <leader>l zo
  noremap <leader>a za
  noremap <leader>m zM
  noremap <leader>i zMzv
  noremap <leader>r zR
  noremap <leader>f zf

  " Cancel hilight search
  nnoremap <silent><Esc><Esc> :<C-u>nohlsearch<CR><C-l>

  " Search by selected word/sentence ( Practical Vim (ja) : https://pragprog.com/titles/dnvim/source_code )
  xnoremap * :<C-u>call <SID>vSetSearch()<CR>/<C-R>=@/<CR><CR>
  xnoremap # :<C-u>call <SID>vSetSearch()<CR>?<C-R>=@/<CR><CR>
  function! s:vSetSearch()
    let temp = @s
    normal! gv"sy
    let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
    let @s = temp
  endfunction

  " Editor lines
  nnoremap j gj
  nnoremap k gk

  " buffers
  nnoremap <silent> <C-j> :<C-u>bprevious<CR>
  nnoremap <silent> <C-k> :<C-u>bnext<CR>

  " Switch CWD to the directory of the open buffer
  nnoremap <leader>cd :<C-u>cd %:p:h<cr>:<C-u>pwd<cr>

  " yank half
  nnoremap Y y$

  " https://qiita.com/grohiro/items/e3dbcc93510bc8c4c812
  nnoremap M :<C-u>call <SID>toggleWindowSize()<CR>
  let s:toggle_window_size = 0
  function! s:toggleWindowSize()
    if s:toggle_window_size ==# 1
      execute "normal \<C-w>="
      let s:toggle_window_size = 0
    else
      :resize
      :vertical resize
      let s:toggle_window_size = 1
    endif
  endfunction

  " vimrc
  nnoremap <leader>v :<C-u>edit $MYVIMRC<CR>

  " memo
  nnoremap <leader>, :<C-u>MemoNew<CR>
  nnoremap <leader>. :<C-u>MemoList<CR>
  nnoremap <leader>/ :<C-u>MemoGrep<CR>

" }}}1 -------------------------------------------------
" filetypes {{{1

  source $HOME/tmp/callmekoheiTODO/callmekoheiTODO.vim

" memo {{{2

  autocmd callmekohei-vimrc BufNewFile,BufRead *.memo call s:vimrc_memo()
  function! s:vimrc_memo() abort
    let &l:filetype    = 'memo'
    let &l:foldmethod  = 'marker'
    let &l:tabstop     = 2
    let &l:softtabstop = 2
    let &l:shiftwidth  = 2
    let &l:ambiwidth   = 'double'
    let &l:wrap        = s:ON
    let &l:display     = 'lastline'
  endfunction

  " Enable syntax highlight between triple back-ticks
  let s:lst = ['fsharp','vim','sh','python']
  autocmd callmekohei-vimrc FileType memo
    \ call map( s:lst, { i,v ->
      \ call( 's:textEnableCodeSnip', [v, '```' . v , '```' , 'SpecialComment'] )
      \ })

  " http://vim.wikia.com/wiki/Different_syntax_highlighting_within_regions_of_a_file
  function! s:textEnableCodeSnip(filetype,start,end,textSnipHl) abort "{{{3
    let ft=toupper(a:filetype)
    let group='textGroup'.ft
    if exists('b:current_syntax')
      let s:current_syntax=b:current_syntax
      " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
      " do nothing if b:current_syntax is defined.
      unlet b:current_syntax
    endif
    execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
    try
      execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
    catch
    endtry
    if exists('s:current_syntax')
      let b:current_syntax=s:current_syntax
    else
      unlet b:current_syntax
    endif
    execute 'syntax region textSnip'.ft.'
    \ matchgroup='.a:textSnipHl.'
    \ start="'.a:start.'" end="'.a:end.'"
    \ contains=@'.group
  endfunction
  "}}}3

" }}}2 -------------------------------------------------
" General {{{2

  " Add syntax of UnicodeSpaces
  autocmd callmekohei-vimrc BufNewFile,BufRead * call matchadd( 'UnicodeSpaces', '\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000' )

  " Trim tail spaces
  autocmd callmekohei-vimrc BufWritePre * call s:trimEnd()

" }}}2 -------------------------------------------------
" Vim script {{{2

  autocmd callmekohei-vimrc BufNewFile,BufRead vimrc,gvimrc setfiletype vim
  autocmd callmekohei-vimrc FileType vim call s:vimrc_vim()
  function! s:vimrc_vim() abort

    let g:vim_indent_cont = 2
    let &l:tabstop        = 2
    let &l:softtabstop    = 2
    let &l:shiftwidth     = 2
    let &l:foldmethod     = 'markder'

    " Add syntax of let-option
    call matchadd( 'OptionKeyword', '\s&\zs\w*\ze$' )
    call matchadd( 'OptionKeyword', '\s&\zs\w*\ze\s')
    call matchadd( 'OptionKeyword', '\s&\(g:\|l:\)\zs\w*\ze\s')

  endfunction

" }}}2 -------------------------------------------------
" quickrun {{{2

  autocmd callmekohei-vimrc FileType quickrun setlocal wrap
  autocmd callmekohei-vimrc FileType quickrun nnoremap <nowait><silent><buffer> q :quit<CR>

" }}}2 -------------------------------------------------
" Text {{{2

  " conflict ambiwidth=double and let &fillchars = vert:│,fold:
  " autocmd callmekohei-vimrc FileType text setlocal ambiwidth=double wrap display=lastline

" }}}2 -------------------------------------------------
" Markdown {{{2

  autocmd callmekohei-vimrc BufNewFile,BufRead *.{md,mdwn,mkd,mkdn,mark*} setlocal filetype=markdown
  autocmd callmekohei-vimrc FileType markdown call s:vimrc_markdown()

  function! s:vimrc_markdown() abort
    let &l:ambiwidth   = 'doble'
    let &l:wrap        = 1
    let &l:display     = 'lastline'
    let &l:foldmethod  = 'expr'
    " let &foldexpr    = get(funcref('s:foldexpr_markdown'), 'name') . '(v:lnum)'
  endfunction

  " function! s:foo(lnum) abort
  "   return match(getline(a:lnum),'^#\s') + 1
  " endfunction

function! s:foldexpr_markdown(lnum) "{{{
    if (a:lnum == 1)
        let l0 = ''
    else
        let l0 = getline(a:lnum-1)
    endif

    " keep track of fenced code blocks
    if l0 =~ '````*' || l0 =~ '\~\~\~\~*'
        if b:fenced_block == 0
            let b:fenced_block = 1
        elseif b:fenced_block == 1
            let b:fenced_block = 0
        endif
    elseif g:vim_markdown_frontmatter == 1
        if b:front_matter == 1
            if l0 == '---'
                let b:front_matter = 0
            endif
        elseif a:lnum == 2
            if l0 == '---'
                let b:front_matter = 1
            endif
        endif
    endif

    if b:fenced_block == 1 || b:front_matter == 1
        " keep previous foldlevel
        return '='
    endif

    let l2 = getline(a:lnum+1)
    if  l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
        " next line is underlined (level 1)
        return '>1'
    elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
        " next line is underlined (level 2)
        if s:vim_markdown_folding_level >= 2
            return '>1'
        else
            return '>2'
        endif
    endif

    let l1 = getline(a:lnum)
    if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
        " fold level according to option
        if s:vim_markdown_folding_level == 1 || matchend(l1, '^#\+') > s:vim_markdown_folding_level
            if a:lnum == line('$')
                return matchend(l1, '^#\+') - 1
            else
                return -1
            endif
        else
            " headers are not folded
            return 0
        endif
    endif

    if l0 =~ '^#' && !s:is_mkdCode(a:lnum-1)
        " previous line starts with hashes
        return '>'.matchend(l0, '^#\+')
    else
        " keep previous foldlevel
        return '='
    endif
endfunction "}}}

" }}}2 -------------------------------------------------
" help {{{2

  " Japanese help text
  let &g:helplang = 'ja,en'

  " Open Vim internal help by K command
  let &g:keywordprg = ':help'

  " Close by q
  autocmd FileType help nnoremap <nowait><silent><buffer>q :quit<CR>

  autocmd callmekohei-vimrc FileType help setlocal foldmethod=indent

" }}}2 -------------------------------------------------
" fsharp {{{2

  " https://github.com/fsharp/vim-fsharp/pull/103
  " needs to set regexpengine before set filetype
  if !has('nvim') && !has('gui_running')
    autocmd callmekohei-vimrc BufNewFile,BufRead *.fs,*.fsi,*.fsx  setglobal regexpengine
  endif

  autocmd callmekohei-vimrc BufNewFile,BufRead *.fs,*.fsi,*.fsx setlocal filetype=fsharp
  autocmd callmekohei-vimrc FileType fsharp call s:vimrc_fsharp()

  " TODO: needs to ajust fold settings
  function! s:vimrc_fsharp() abort
    let &l:errorformat   = '%f(%l\,%c):\ %m,%-G %.%#,%-G,%-G%[%^/]%.%#'
    let &l:previewheight = 5
    let &l:splitbelow    = s:OFF
    let &l:foldmethod    = 'indent'
    let &l:foldlevel     = 1
    let &l:foldminlines  = 3
  endfunction

  " ---------------------------------------------------------
  "                   Setting for QuickRun
  " ---------------------------------------------------------

  if has('mac')
    let s:command = 'fsharpi --readline-'
  elseif has('win32')
    let s:command = 'fsi'
  elseif has('unix')
    let s:command = 'fsharpi'
  else
    let s:command = 'fsharpi'
  endif

  let g:quickrun_config.fsharp      = {}
  let g:quickrun_config.fsharpCheck = {}
  let g:quickrun_config.fsharpi     = {}

  let g:quickrun_config.fsharp = {
    \  'command'                          : s:command
    \ ,'runner'                           : 'concurrent_process'
    \ ,'runner/concurrent_process/load'   : '#load "%S";;'
    \ ,'runner/concurrent_process/prompt' : '> '
    \ ,'hook/time/format'                 : "\n*** time : %g s ***"
    \ ,'hook/time/dest'                   : ''
    \ ,"outputter/buffer/split"           : 'vertical'
  \}

  let g:quickrun_config.fsharpCheck = {
    \  'command'                          : s:command
    \ ,'runner'                           : 'concurrent_process'
    \ ,'runner/concurrent_process/load'   : '#load "%S";;'
    \ ,'runner/concurrent_process/prompt' : '> '
    \ ,'hook/time/enable'                 : 0
    \ ,"outputter/buffer/close_on_empty"  : 1
    \ ,"outputter"                        : 'quickfix'
    \ ,'outputter/buffer/split'           : ':set splitblow',
  \}

  let g:quickrun_config.fsharpi = {
    \  'exec'    : [ '%c %s:p:r.fsx' ]
    \ ,'command' : 'fsharpi'
    \ ,'args'    : '%{input("args> ")}'
  \}

  " very unstable (^_^;;
  " https://github.com/thinca/vim-quickrun/issues/175
  if has('nvim') || has('gui_running')
    autocmd callmekohei-vimrc BufWinEnter,BufWritePost *.fsx call quickrun#run( g:quickrun_config.fsharpCheck )
  else
    autocmd callmekohei-vimrc BufWritePost *.fsx call quickrun#run( g:quickrun_config.fsharpCheck )
  endif

" }}}2 -------------------------------------------------
" dependencies {{{2

  autocmd callmekohei-vimrc BufNewFile,BufRead *.dependencies call s:vimrc_dependencies()
  function! s:vimrc_dependencies() abort
    let &l:filetype   = 'dependencies'
    let &l:dictionary = &l:dictionary . ',' . expand('~/.vim/dictionary/dic_dependencies', 1)
  endfunction

" }}}2 -------------------------------------------------
" Toml {{{2

  autocmd callmekohei-vimrc FileType toml call s:vimrc_toml()

  function! s:vimrc_toml() abort
    setlocal tabstop=2 softtabstop=2 shiftwidth=2
    let b:partedit_opener   = 'vsplit'
    let b:partedit_filetype = 'vim'
  endfunction

" }}}2 -------------------------------------------------
" QuickFix {{{2

  " https://gist.github.com/juanpabloaj/5845848#file-adjustwindowheight-vim
  autocmd callmekohei-vimrc FileType qf call s:adjustWindowHeight(3, 10)
  function! s:adjustWindowHeight(minheight, maxheight)
    let l = 1
    let n_lines = 0
    let w_width = winwidth(0)
    while l <= line('$')
      " number to float for division
      let l_len = strlen(getline(l)) + 0.0
      let line_width = l_len/w_width
      let n_lines += float2nr(ceil(line_width))
      let l += 1
    endw
    exe max([min([n_lines, a:maxheight]), a:minheight]) . "wincmd _"
  endfunction

" }}}2 -------------------------------------------------
" Bash script {{{2

  autocmd callmekohei-vimrc FileType sh call s:vimrc_bash()
  autocmd callmekohei-vimrc BufWinEnter,BufWritePost *.bash call quickrun#run( g:quickrun_config.bashCheck )

  function! s:vimrc_bash() abort

    let g:is_bash      = 1
    let g:sh_no_error  = 1
    let &l:errorformat = '%f:\ line\ %l:\ %m'

    " quickrun settings
    let g:quickrun_config.sh        = {}
    let g:quickrun_config.bashCheck = {}

    let g:quickrun_config.sh        = { 'command': 'bash' }
    let g:quickrun_config.bashCheck = {
      \  'exec'                            : [ '%c -n %s:p:r.bash' ]
      \ ,'command'                         : 'bash'
      \ ,'hook/time/enable'                : 0
      \ ,"outputter/buffer/close_on_empty" : 1
      \ ,"outputter"                       : 'quickfix'
      \ ,'outputter/buffer/split'          : ':set splitblow',
    \}

  endfunction

" }}}2 -------------------------------------------------
" Python {{{2

  autocmd callmekohei-vimrc BufRead,BufNewFile *.pdbrc setlocal filetype=python
  autocmd callmekohei-vimrc FileType python call s:vimrc_python()
  function! s:vimrc_python() abort
    let g:quickrun_config.python = {}
    let g:quickrun_config.python = { 'command': 'python3' }
  endfunction

" }}}2 -------------------------------------------------

" }}}1 -------------------------------------------------
" nvim {{{1

  if has('nvim')
    let g:python_host_prog  = '/usr/local/bin/python2'
    let g:python3_host_prog = '/usr/local/bin/python3'

    if exists('&inccommand')
      let &g:inccommand = 'nosplit'
    endif

    " enable to local settings
    let &g:runtimepath = &g:runtimepath . ',' . expand('~/.vim/',1)
  endif

" }}}1 -------------------------------------------------
" gvim {{{1

  if has('gui_running')

    " font
    let s:fontName = 'Droid Sans Mono for Powerline Nerd Font Complete'
    let s:fontSize = 'h14'
    let &g:guifont   = s:fontName . ':' . s:fontSize
    let &g:linespace = 3

    " window size
    let &g:columns   = 80 " width
    let &g:lines     = 30 " hight
    let &g:cmdheight = 2

    " Don't flick cursor.
    setglobal guicursor&
    setglobal guicursor+=a:blinkon0

    " key mappings
    noremap  ; :
    noremap  : ;
    lnoremap ; :
    lnoremap : ;
    tnoremap ; :
    tnoremap : ;

  endif

" }}}1 -------------------------------------------------
" mac {{{1

  " Macではデフォルトの'iskeyword'がcp932に対応しきれていないので修正
  " https://github.com/koron/vim-kaoriya/blob/master/kaoriya/vim/vimrc#L221
  if has('mac')
    let &iskeyword = '@,48-57,_,128-167,224-235'
  endif

  " TODO: needs more infomations!
  " ふむ〜 日本語自動offを使うとなんとなく挙動がおかしくなる・・・
  " if has('mac')
  "   set ttimeoutlen=1
  "   let s:async = '&'
  "   let s:imeoff = 'osascript -e "tell application \"System Events\" to key code 102"' . ' ' . s:async
  "   autocmd callmekohei-vimrc InsertLeave * :call system(s:imeoff)
  "   noremap <silent> <ESC> <ESC>:call system(s:imeoff)<CR>
  " endif

" }}}1 -------------------------------------------------
" util {{{1

  command! -nargs=+ -complete=command Capture QuickRun -type vim -src <q-args>
  command! SelfFileDelete call delete(expand('%',1))
  inoreabbrev <expr> ---- repeat('-', 60 - col('.'))

  function! s:trim() abort "{{{2

    :normal! ma

    let l:range = '%'

    " Replace unicode spaces to normal space
    let l:unicodeSpaces  = '\%u00A0\|\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000'
    :execute l:range 'substitute' '/' . l:unicodeSpaces . '/ /ge'

    " trim head spaces
    let headSpaces = '^\s+\ze\S'
    :execute l:range 'substitute' '/\v' . l:headSpaces . '//ge'

    " trim tail spaces
    let tailSpaces = '\s+$'
    :execute l:range 'substitute' '/\v' . l:tailSpaces . '//ge'

    :normal! `a

  endfunction "}}}2
  function! s:trimStart() abort "{{{2

    :normal! ma

    let l:range = '%'

    " Replace unicode spaces to normal space
    let l:unicodeSpaces  = '\%u00A0\|\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000'
    :execute l:range 'substitute' '/' . l:unicodeSpaces . '/ /ge'

    " trim head spaces
    let headSpaces = '^\s+\ze\S'
    :execute l:range 'substitute' '/\v' . l:headSpaces . '//ge'

    :normal! `a

  endfunction "}}}2
  function! s:trimEnd() abort "{{{2

    :normal! ma

    let l:range = '%'

    " Replace unicode spaces to normal space
    let l:unicodeSpaces  = '\%u00A0\|\%u180E\|\%u2000\|\%u2001\|\%u2002\|\%u2003\|\%u2004\|\%u2005\|\%u2006\|\%u2007\|\%u2008\|\%u2009\|\%u200A\|\%u2028\|\%u2029\|\%u202F\|\%u205F\|\%u3000'
    :execute l:range 'substitute' '/' . l:unicodeSpaces . '/ /ge'

    " trim tail spaces
    let tailSpaces = '\s+$'
    :execute l:range 'substitute' '/\v' . l:tailSpaces . '//ge'

    :normal! `a

  endfunction "}}}2
  " do center selected strings {{{2

  command! -range Center2 call s:center2(<line1>,<line2>)
  function! s:center2(fst,lst) abort
    let l:maxcol = max(map(getline(a:fst,a:lst),'strlen(v:val)'))
    execute (a:fst) "," (a:lst) "center" l:maxcol
  endfunction

  "}}}2
  " cleare selected empty lines {{{2

  command! -range ClearEmptyLines call s:clearEmptyLines(<line1>,<line2>)
  function! s:clearEmptyLines(fst,lst) abort
    execute (a:fst) "," (a:lst) 'vglobal/\S/d'
  endfunction

  "}}}2
  command! Space2from4 call s:space2from4() "{{{2
  function! s:space2from4() abort
    let &l:tabstop     = 4
    let &l:softtabstop = 4
    let &l:expandtab   = s:OFF
    retab!
    let &l:tabstop     = 2
    let &l:softtabstop = 2
    let &l:expandtab   = s:ON
    retab
  endfunction "}}}2
  command! Space4from2 call s:space4from2() "{{{2
  function! s:space4from2() abort
    let &l:tabstop     = 2
    let &l:softtabstop = 2
    let &l:expandtab   = s:OFF
    retab!
    let &l:tabstop     = 4
    let &l:softtabstop = 4
    let &l:expandtab   = s:ON
    retab
  endfunction "}}}2

" }}}1 -------------------------------------------------
" __END__  "{{{1

  " must be written at the last. see :help 'secure'
  let &g:secure = s:ON

  " vim: expandtab softtabstop=2 shiftwidth=2
  " vim: foldmethod=marker
  " vim: foldcolumn=5
